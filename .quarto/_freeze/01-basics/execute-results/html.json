{
  "hash": "446603f5e1d95374f744ef864e014b8a",
  "result": {
    "markdown": "---\ntitle: \"Programming Basics\"\n---\n\n## Objectives {#ch0-objectives .unnumbered}\n\nIn this chapter, we will review some basics of general computer programming, and \nhow they appear in `python`.\n\n:::{.callout-learn-more .icon collapse=\"true\"}\nSome of you may find this material to be unneeded review - if so, great!\n\n\nBut if you are new to programming, or it has been a while, [this tutorial](https://app.dataquest.io/m/605/python-programming/1/learning-data-science)\nmay help you refresh your knowledge.\n\n:::\n\n\n## Basic Data Types {#basic-data-types}\n\nIt is important to have a base grasp on the types of data you might see in data analyses.\n\n### Values and Types\n\nLet's start this section with some basic vocabulary.\n\n-   a **value** is a basic unit of stuff that a program works with, like `1`, `2`, `\"Hello, World\"`, and so on.\n-   values have **types** - `2` is an integer, `\"Hello, World\"` is a string (it contains a \"string\" of letters). Strings are in quotation marks to let us know that they are not variable names.\n\nIn `python`, there are some very basic data types:\n\n-   **logical** or **boolean** - False/True or 0/1 values. Sometimes, boolean is shortened to **bool**\n\n-   **integer** - whole numbers (positive or negative)\n\n-   **double** or **float** - decimal numbers.\n\n    -   **float** is short for floating-point value.\n    -   **double** is a floating-point value with more precision (\"double precision\").[^00-prereading-1]\n\n-   **numeric** - `python` uses the name **numeric** to indicate a decimal value, regardless of precision.\n\n-   **character** or **string** or **object** - holds text, usually enclosed in quotes.\n\n[^00-prereading-1]: This means that doubles take up more memory but can store more decimal places. You don't need to worry about this in anything we will do.\n\nIf you don't know what type a value is, `python` has a function to help you with that.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ntype(False)\ntype(2) # by default, python treats whole numbers as integers\ntype(2.0)  # to force it not to be an integer, add a .0\ntype(\"Hello, programmer!\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nstr\n```\n:::\n:::\n\n\n:::{.callout-warning}\nIn `python`, boolean values are `True` and `False`. Capitalization matters a LOT.\n\nOther details: if we try to write a million, we would write it `1000000` instead of `1,000,000`. Commas are used for separating numbers, not for proper spacing and punctuation of numbers. This is a hard thing to get used to but very important -- especially when we start reading in data.\n:::\n\n### Variables\n\nProgramming languages use **variables** - names that refer to values. Think of a variable as a container that holds something - instead of referring to the value, you can refer to the container and you will get whatever is stored inside.\n\nIn `python`, we **assign** variables values using the syntax `object_name = value` You can read this as \"object name gets value\" in your head.\n\n``` {.python .cell-code}\nmessage = \"So long and thanks for all the fish\"\nyear = 2025\nthe_answer = 42\nearth_demolished = False\n```\n\n\nWe can then use the variables - do numerical computations, evaluate whether a proposition is true or false, and even manipulate the content of strings, all by referencing the variable by name.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nmessage + \", sang the dolphins.\"\n\nyear + the_answer\n\nnot earth_demolished\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nTrue\n```\n:::\n:::\n\n\n#### Valid Names\n\n> There are only two hard things in Computer Science: cache invalidation and naming things.\\\n> -- Phil Karlton\n\nObject names must start with a letter and can only contain letters, numbers, and `_`.\n\nWhat happens if we try to create a variable name that isn't valid?\n\nStarting a variable name with a number will get you an error message that lets you know that something isn't right.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n1st_thing = \"No starting with numbers\"\n\nfirst~thing = \"No other symbols\"\n\nfirst.thing = \"Periods have a particular meaning!\"\n```\n\n::: {.cell-output .cell-output-error}\n```\nSyntaxError: invalid syntax (3761243318.py, line 1)\n```\n:::\n:::\n\n\nNaming things is difficult! When you name variables, try to make the names descriptive - what does the variable hold? What are you going to do with it? The more (concise) information you can pack into your variable names, the more readable your code will be.\n\n:::{.callout-learn-more .icon collapse=\"true\"}\n[Why is naming things hard?](https://neilkakkar.com/why-is-naming-things-hard.html) - Blog post by Neil Kakkar\n:::\n\nThere are a few different conventions for naming things that may be useful:\n\n-   `some_people_use_snake_case`, where words are separated by underscores\n-   `somePeopleUseCamelCase`, where words are appended but anything after the first word is capitalized (leading to words with humps like a camel).\n-   A few people mix conventions with `variables_thatLookLike_this` and they are almost universally hated.\n\nAs long as you pick ONE naming convention and don't mix-and-match, you'll be fine. It will be easier to remember what you named your variables (or at least guess) and you'll have fewer moments where you have to go scrolling through your script file looking for a variable you named.\n\n### Type Conversions\n\nWe talked about values and types above, but skipped over a few details because we didn't know enough about variables. It's now time to come back to those details.\n\nWhat happens when we have an integer and a numeric type and we add them together? Hopefully, you don't have to think too hard about what the result of `2 + 3.5` is, but this is a bit more complicated for a computer for two reasons: storage, and arithmetic.\n\nIn days of yore, programmers had to deal with memory allocation - when declaring a variable, the programmer had to explicitly define what type the variable was. This tended to look something like the code chunk below:\n\n    int a = 1\n    double b = 3.14159\n\nTypically, an integer would take up 32 bits of memory, and a double would take up 64 bits, so doubles used 2x the memory that integers did. R is **dynamically typed**, which means you don't have to deal with any of the trouble of declaring what your variables will hold - the computer automatically figures out how much memory to use when you run the code. So we can avoid the discussion of memory allocation and types because we're using higher-level languages that handle that stuff for us[^00-prereading-2].\n\n[^00-prereading-2]: In some ways, this is like the difference between an automatic and a manual transmission - you have fewer things to worry about, but you also don't know what's going on under the hood nearly as well\n\nBut the discussion of types isn't something we can completely avoid, because we still have to figure out what to do when we do operations on things of two different types - even if memory isn't a concern, we still have to figure out the arithmetic question.\n\nSo let's see what happens with a couple of examples, just to get a feel for **type conversion** (aka **type casting** or **type coercion**), which is the process of changing an expression from one data type to another.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ntype(2 + 3.14159) # add integer 2 and pi\ntype(2 + True) # add integer 2 and TRUE\ntype(True + False) # add TRUE and FALSE\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nint\n```\n:::\n:::\n\n\nAll of the examples above are 'numeric' - basically, a catch-all class for things that are in some way, shape, or form numbers. Integers and decimal numbers are both numeric, but so are logicals (because they can be represented as 0 or 1).\n\nYou may be asking yourself at this point why this matters, and that's a decent question. We will eventually be reading in data from spreadsheets and other similar tabular data, and types become *very* important at that point, because we'll have to know how `python` handles type conversions.\n\n:::{.callout-check-in .icon}\n\nDo a bit of experimentation - what happens when you try to add a string and a number? Which types are automatically converted to other types? Fill in the following table in your notes:\n\nAdding a \\_\\_\\_ and a \\_\\_\\_ produces a \\_\\_\\_:\n\n| Logical | Integer | Decimal | String |     |\n|---------|---------|---------|--------|-----|\n| Logical |         |         |        |     |\n| Integer |         |         |        |     |\n| Decimal |         |         |        |     |\n| String  |         |         |        |     |\n:::\n\nAbove, we looked at automatic type conversions, but in many cases, we also may want to convert variables manually, specifying exactly what type we'd like them to be. A common application for this in data analysis is when there are \"NA\" or \"   \" or other indicators in an otherwise numeric column of a spreadsheet that indicate missing data: when this data is read in, the whole column is usually read in as character data. So we need to know how to tell `python` that we want our string to be treated as a number, or vice-versa.\n\nIn python, we can explicitly convert a variable's type using functions (`int`, `float`, `str`, etc.).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nx = 3\ny = \"3.14159\"\n\nx + y\n\nx + float(y)\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n```\n:::\n:::\n\n\n## Operators and Functions\n\nIn addition to variables, **functions** are extremely important in programming.\n\nLet's first start with a special class of functions called operators. You're probably familiar with operators as in arithmetic expressions: +, -, /, \\*, and so on.\n\nHere are a few of the most important ones:\n\n| Operation        | python symbol |\n|------------------|----------|\n| Addition         | `+`      |\n| Subtraction      | `-`      |\n| Multiplication   | `*`      |\n| Division         | `/`      |\n| Integer Division | `//`    |\n| Modular Division | `%`     |\n| Exponentiation   | `**`      |\n\nNote that integer division is the whole number answer to A/B, and modular division is the fractional remainder when A/B.\n\nSo `14 // 3` would be 4, and `14 % 3` would be 2.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n14 // 3\n14 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n2\n```\n:::\n:::\n\n\nNote that these operands are all intended for scalar operations (operations on a single number) - vectorized versions, such as matrix multiplication, are somewhat more complicated.\n\n### Order of Operations\n\n`python` operates under the same mathematical rules of precedence that you learned in school. You may have learned the acronym PEMDAS, which stands for Parentheses, Exponents, Multiplication/Division, and Addition/Subtraction. That is, when examining a set of mathematical operations, we evaluate parentheses first, then exponents, and then we do multiplication/division, and finally, we add and subtract.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n(1+1)**(5-2) # 2 ^ 3 = 8\n1 + 2**3 * 4 # 1 + (8 * 4)\n3*1**3 # 3 * 1\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n3\n```\n:::\n:::\n\n\n### String Operations\n\nThe `+` operator also works on strings.  Just remember that `python` doesn't speak English - it neither knows nor cares if your strings are words, sentences, etc.  So if you want to create good punctuation or spacing, that needs to be done in the code.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ngreeting = \"howdy\"\nperson = \"pardner\"\n\ngreeting + person\ngreeting + \", \" + person\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n'howdy, pardner'\n```\n:::\n:::\n\n\n### Functions\n\n**Functions** are sets of instructions that take **arguments** and **return** values. Strictly speaking, operators (like those above) are a special type of functions -- but we aren't going to get into that now.\n\nWe're also not going to talk about how to create our own functions just yet. We only need to know how to *use* functions.  Let's look at the official documentation for the function `round`()`.\n\n```\nround(number, ndigits=None)\n\nReturn number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input.\n```\n\nThis tells us that the function requires one argument, `number`, a number to round.  You also have the *option* to include a second argument, `ndigits`, if you want to round to something other than a whole number.\n\nWhen you call a function, you can either use the names of the arguments, or simply provide the information in the expected order.\n\nBy convention, we usually use names for optional arguments but not required ones.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nround(number = 2.718)\nround(2.718, 2)\n\n\nround(2.718)\nround(2.718, ndigits = 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n2.72\n```\n:::\n:::\n\n\n:::{.callout-warning}\nThe names of functions and their arguments are chosen by the developer who created them.  You should **never** simply assume what a function or argument will do based on the name; always check documentation or try small test examples if you aren't sure.\n:::\n\n\n## Data Structures {#data-structures}\n\nIn the previous section, we discussed 4 different data types: strings/characters, numeric/double/floats, integers, and logical/booleans. As you might imagine, things are about to get more complicated.\n\nData **structures** are more complicated arrangements of information.\n\n| Homogeneous | Heterogeneous |            |\n|-------------|---------------|------------|\n| 1D          | vector        | list       |\n| 2D          | matrix        | data frame |\n| N-D         | array         |            |\n\n\n**Methods** or **attributes** are a special type of function that operate only on a specific data structure When using a method in `python`, you can use a period `.` to apply the function to an object.\n\n``` {.python .cell-code}\nmy_nums = [1,2,3,4,5]\nmy_nums.sort()\n```\n\n\nCareful, though!  If a function is not specifically designed to be an attribute of the structure, this `.` trick won't work.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nmy_nums.round()\n```\n\n::: {.cell-output .cell-output-error}\n```\nAttributeError: 'list' object has no attribute 'round'\n```\n:::\n:::\n\n\n### Lists\n\nA **list** is a one-dimensional column of heterogeneous data - the things stored in a list can be of different types.\n\n![A lego list: the bricks are all different types and colors, but they are still part of the same data structure.](images/lego-list.png)\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nx = [\"a\", 3, True]\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n['a', 3, True]\n```\n:::\n:::\n\n\nThe most important thing to know about lists, for the moment, is how to pull things out of the list. We call that process **indexing**.\n\n#### Indexing\n\nEvery element in a list has an **index** (a location, indicated by an integer position)[^00-prereading-4].\n\n[^00-prereading-4]: Throughout this section (and other sections), lego pictures are rendered using https://www.mecabricks.com/en/workshop. It's a pretty nice tool for building stuff online!\n\nIn `python`, we count from 0.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nx = [\"a\", 3, True]\n\nx[0] # This returns a list\nx[0:2] # This returns multiple elements in the list\n\nx.pop(0)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n'a'\n```\n:::\n:::\n\n\nList indexing with `[]` will return a list with the specified elements.\n\nTo actually retrieve the item in the list, use the `.pop` attribute. The only downside to `.pop` is that you can only access one thing at a time.\n\nWe'll talk more about indexing as it relates to vectors, but indexing is a general concept that applies to just about any multi-value object.\n\n### Vectors\n\nA **vector** is a one-dimensional column of homogeneous data. Homogeneous means that every element in a vector has the same data type.\n\nWe can have vectors of any data type and length we want: ![vectors of different data types](images/lego-set-of-vectors.png)\n\nBase `python` does not actually have a vector-type object! However, in data analysis we often have reasons to want a single-type data structure, so we will load an extra function called `array` from the `numpy` **library** to help us out.  (More on libraries later!)\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfrom numpy import array\n\ndigits_pi = array([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])\n\n# Access individual entries\ndigits_pi[1]\n\n# Print out the vector\ndigits_pi\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])\n```\n:::\n:::\n\n\nWe can pull out items in a vector by indexing, but we can also replace specific elements as well:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfavorite_cats = array([\"Grumpy\", \"Garfield\", \"Jorts\", \"Jean\"])\n\nfavorite_cats\n\nfavorite_cats[2] = \"Nyan Cat\"\n\nfavorite_cats\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray(['Grumpy', 'Garfield', 'Nyan Cat', 'Jean'], dtype='<U8')\n```\n:::\n:::\n\n\nIf you're curious about any of these cats, see the footnotes[^00-prereading-5].\n\n[^00-prereading-5]: [Grumpy cat](https://www.grumpycats.com/), [Garfield](https://www.garfield.com/), [Nyan cat](https://en.wikipedia.org/wiki/Nyan_Cat). Jorts and Jean: [The initial post](https://www.reddit.com/r/AmItheAsshole/comments/rfwgmc/aita_for_perpetuating_ethnic_stereotypes_about/) and the [update](https://www.reddit.com/user/throwawayorangecat/comments/rgi000/update_aita_for_perpetuating_stereotypes_about/) (both are worth a read because the story is hilarious). The cats also have a [Twitter account](https://twitter.com/JortsTheCat) where they promote workers rights.\n\n#### Boolean masking\n\nAs you might imagine, we can create vectors of all sorts of different data types. One particularly useful trick is to create a **logical vector** that tells us which elements of a corresponding vector we want to keep.\n\n![lego vectors - a pink/purple hued set of 1x3 bricks representing the data and a corresponding set of 1x1 grey and black bricks representing the logical index vector of the same length](images/lego-logical-full.png)\n\nIf we let the black lego represent \"True\" and the grey lego represent \"False\", we can use the logical vector to pull out all values in the main vector.\n\n| Black = True, Grey = False                                                                                                                                                                                                                                                                             | Grey = True, Black = False                                                                                                                                                                                                                                                                            |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| ![a pink/purple hued set of 1x3 bricks representing a vector and a corresponding set of 1x1 black bricks representing the logical index vector of the same length. The grey bricks (and corresponding values of the previous vector) have been removed (filtered out).](images/lego-logical-black.png) | ![a pink/purple hued set of 1x3 bricks representing a vector and a corresponding set of 1x1 grey bricks representing the logical index vector of the same length. The black bricks (and corresponding values of the previous vector) have been removed (filtered out).](images/lego-logical-grey.png) |\n\nNote that for boolean masking to work properly, the logical index must be the same length as the vector we're indexing. This constraint will return when we talk about data frames, but for now just keep in mind that logical indexing doesn't make sense when this constraint isn't true.\n\n:::{.callout-example .icon}\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Define a character vector\nweekdays = array([\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"])\nweekend = array([\"Sunday\", \"Saturday\"])\n\n# Create logical vectors manually\nrelax_days = array([True, False, False, False, False, False, True])\n\n# Create logical vectors automatically\nfrom numpy import isin     # get a special function for arrays\nrelax_days = isin(weekdays, weekend) \n\nrelax_days\n\n# Using logical vectors to index the character vector\nweekdays[relax_days] \n\n# Using ~ to reverse the True and False\nweekdays[~relax_days] \n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n      dtype='<U9')\n```\n:::\n:::\n\n\n:::\n\n#### Reviewing Types\n\nAs vectors are a collection of things of a single type, what happens if we try to make a vector with differently-typed things?\n\n:::{.callout-example .icon}\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\narray([2, False, 3.1415, \"animal\"]) # all converted to strings\n\narray([2, False, 3.1415]) # converted to numerics\n\narray([2, False]) # converted to integers\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([2, 0])\n```\n:::\n:::\n\n\n:::\n\nAs a reminder, this is an example of **implicit** type conversion - python decides what type to use for you, going with the type that doesn't lose data but takes up as little space as possible. \n\n:::{.callout-warning}\n\nImplicit type conversions may seem convenient, but they are dangerous!  Imagine that you created one of the arrays above, expecting it to be numeric, and only found out later that python had made it into strings.\n\n:::\n\n### Matrices\n\nA **matrix** is the next step after a vector - it's a set of values arranged in a two-dimensional, rectangular format.\n\n![lego depiction of a 3-row, 4-column matrix of 2x2 red-colored blocks](images/lego-2x2-matrix.png)\n\nOnce again, we need to use the `numpy` package to allow the *matrix* type to exist in `python`.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfrom numpy import matrix\n\nmatrix([[1,2,3], [4,5,6]])\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nmatrix([[1, 2, 3],\n        [4, 5, 6]])\n```\n:::\n:::\n\n\n:::{.callout-note}\nNotice how we give the `matrix()` function an argument that is a \"list of lists\".  That is, the first item in the list is `[1,2,3]` which is itself a list.\n\nYou can always think of lists as the most \"neutral\" data structure - if you don't know what you want to use, it's reasonably to start with the list, and then adjust from there, as we have with the `array()` and `matrix()` functions from `numpy`.\n:::\n\n\n#### Indexing in Matrices {#indexing-matrices}\n\n`python` uses \\[row, column\\] to index matrices. To extract the bottom-left element of a 3x4 matrix, we would use \\[2,0\\] to get to the third row and first column entry (remember that Python is 0-indexed).\n\nAs with vectors, you can replace elements in a matrix using assignment.\n\n:::{.callout-example .icon}\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nmy_mat = matrix([[1,2,3,4], [4,5,6,7], [7,8,9,10]])\n\nmy_mat\n\nmy_mat[2,0] = 500\n\nmy_mat\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nmatrix([[  1,   2,   3,   4],\n        [  4,   5,   6,   7],\n        [500,   8,   9,  10]])\n```\n:::\n:::\n\n\n:::\n\nWe will not use matrices often in this class, but there are many math operations that are very specific to matrices.  If you continue on in your data science journey, you will probably eventually need to do matrix algebra in python.\n\n:::{.callout-learn-more .icon collapse=\"true\"}\n[Tutorial: Linear Algebra in python](https://realpython.com/python-linear-algebra/)\n:::\n\n## Libraries and Open-Source\n\n\n### Open-source languages\n\nOne of the great things about python is that it is an **open-source language**.  This means that it was and is developed by individuals in a community rather than a private company, and the core code of it is visible to everyone.\n\nThe major consequences are:\n\n1. It is free for anyone to use, rather than behind a paywall.  *(SAS or Java are examples of languages produced by private companies that require paid licenses to use.)*\n\n2. The language grows quickly, and in many diverse ways, because anyone at all can write their own programs. *(You will write functions in a couple weeks!)*\n\n3. You are not allowed to sell your code for profit. *(You can still write private code to help your company with a task - but you may not charge money to others for the programs themselves.)*\n\n:::{.callout-opinion .icon collapse=\"true\"}\nWe believe very strongly in the philosophy of open-source.  However, it does have its downsides: mainly, that nearly all progress in the language is on a volunteer, community basis.  \n\nAs a user of open source tools, we hope you will give back in whatever ways you can - sharing your work publicly, helping others learn, and encouraging private companies to fund open-source work.\n\n![](https://mc-cdn.com/8779571f940f2dc2f7ae06312a086e69.jpg){width=\"50%\" fig-align=\"center\"}\n:::\n\n\n:::{.callout-learn-more .icon collapse=\"true\"}\n[This very recent article](https://www.politico.com/newsletters/digital-future-daily/2023/05/22/open-source-wants-to-eat-the-internet-000982290), about the role of open source in today's world of AI and social media, is quite interesting!\n:::\n\n### Libraries\n\nWhen an open-source developer creates a new collection of functions and capabilities for `python`, and they want it to be easily usable and accessible to others, they bundle their code into a **library**.  (You will sometimes here this called a **package**.)\n\nPackages that meet certain standards of quality and formatting are added to the [Python Package Index](https://pypi.org/), after which they can be esailly installed with  [pip](https://pypi.org/project/pip/) (\"package installer for python\").\n\nMost of the packages we will use in this class actually come pre-installed with *Anaconda*, so we won't have to worry about this too much.\n\n:::{.callout-check-in .icon}\nOne package we need that is not pre-installed is `plotnine`.\n\nOpen up either a terminal or a Jupyter notebook in Anaconda. Then type\n\n```\npip install plotnine\n```\n:::\n\n:::{.callout-opinion .icon collapse=\"true\"}\nPython is notoriously frustrating for managine package installs.  We will keep things simple in this class, but if you reach a point where you are struggling with libraries, know that you are not alone.\n\n![](https://i.redd.it/imbmky0k2zh21.jpg){width=\"50%\" fig-align=\"center\"}\n:::\n\n### Using library functions\n\nWhen you want to use functions from a library in your current code project, you have two options:\n\n#### 1. Import the whole library\n\nIt is possible to load the full functionality of a library into your notebook project by adding an `import` statement in your very first code chunk.\n\nThe downside of this is that you then need to reference all those functions using the package name:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nimport numpy\n\nmy_nums = numpy.array([1,2,3,4,5])\nnumpy.sum(my_nums)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n15\n```\n:::\n:::\n\n\nBecause this can get tedious, it's common practice to give the package a \"nickname\" that is shorter:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nimport numpy as np\nmy_nums = np.array([1,2,3,4,5])\nnp.sum(my_nums)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n15\n```\n:::\n:::\n\n\n:::{.callout-learn-more .icon collapse=\"true\"}\n\nThe reason for needing to use the library names is that nothing stops two developers from choosing the same name for their function.  Python needs a way to know which library's function you intended to use.\n\n:::\n\n#### 2. Import only the functions you need.\n\nIf you only need a handful of functions from the library, and you want to avoid the extra typing of including the package name/nickname, you can pull those functions in directly:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nfrom numpy import array, sum\n\nmy_nums = array([1,2,3,4,5])\nsum(my_nums)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n15\n```\n:::\n:::\n\n\n## Data Frames\n\nSince we are interested in using `python` specifically for data analysis, we will mention one more important Data Structure:  a data frame.\n\nUnlike lists (which can contain anything at all) or matrices (which must store all the same type of data), data frames are restricted by **column**. That is, every data entry within a single column must be the same *type*; but two columns in the same data frame can have two different types.\n\nOne way to think of a data frame is as a *list* of *vectors* that all have *the same length*.\n\n#### Pandas\n\nAs with vectors and matrices, we need help from an external package to construct and work efficiently with data frames.  This library is called `pandas`, and you will learn many of its functions next week.\n\nFor now, let's just look at a pandas data frame:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nimport pandas as pd\n\ndat = pd.read_csv(\"https://gist.githubusercontent.com/slopp/ce3b90b9168f2f921784de84fa445651/raw/4ecf3041f0ed4913e7c230758733948bc561f434/penguins.csv\")\n\ndat\n\ndat.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 344 entries, 0 to 343\nData columns (total 9 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   rowid              344 non-null    int64  \n 1   species            344 non-null    object \n 2   island             344 non-null    object \n 3   bill_length_mm     342 non-null    float64\n 4   bill_depth_mm      342 non-null    float64\n 5   flipper_length_mm  342 non-null    float64\n 6   body_mass_g        342 non-null    float64\n 7   sex                333 non-null    object \n 8   year               344 non-null    int64  \ndtypes: float64(4), int64(2), object(3)\nmemory usage: 24.3+ KB\n```\n:::\n:::\n\n\nNotice how the columns all have specific types: integers, floats, or strings (\"object\").  They also each have names.  We can access the vector of information in one column like so...\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ndat.body_mass_g\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n0      3750.0\n1      3800.0\n2      3250.0\n3         NaN\n4      3450.0\n        ...  \n339    4000.0\n340    3400.0\n341    3775.0\n342    4100.0\n343    3775.0\nName: body_mass_g, Length: 344, dtype: float64\n```\n:::\n:::\n\n\n... which then lets us do things to that column vector just as we might for standalone vectors:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n## using methods\ndat.body_mass_g.mean()\n\n## editing elements\ndat.body_mass_g[0] = 10000000\ndat.body_mass_g\n\n## boolean masking\nbig_penguins = dat.body_mass_g > 6000\ndat.loc[big_penguins]\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/fl/kkm0fj_n13g65nk3fx77_kq80000gp/T/ipykernel_83986/2607967951.py:5: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=26}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>rowid</th>\n      <th>species</th>\n      <th>island</th>\n      <th>bill_length_mm</th>\n      <th>bill_depth_mm</th>\n      <th>flipper_length_mm</th>\n      <th>body_mass_g</th>\n      <th>sex</th>\n      <th>year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>Adelie</td>\n      <td>Torgersen</td>\n      <td>39.1</td>\n      <td>18.7</td>\n      <td>181.0</td>\n      <td>10000000.0</td>\n      <td>male</td>\n      <td>2007</td>\n    </tr>\n    <tr>\n      <th>169</th>\n      <td>170</td>\n      <td>Gentoo</td>\n      <td>Biscoe</td>\n      <td>49.2</td>\n      <td>15.2</td>\n      <td>221.0</td>\n      <td>6300.0</td>\n      <td>male</td>\n      <td>2007</td>\n    </tr>\n    <tr>\n      <th>185</th>\n      <td>186</td>\n      <td>Gentoo</td>\n      <td>Biscoe</td>\n      <td>59.6</td>\n      <td>17.0</td>\n      <td>230.0</td>\n      <td>6050.0</td>\n      <td>male</td>\n      <td>2007</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Summary\n\nWhew!  How's that for an overview?\n\n![](https://media.tenor.com/88DfzQS5tlQAAAAC/adventure-time-demon-cat.gif){width='60%' fig-align='center'}\n\nThe most important takeaways from this chapter are:\n\n* Objects in python have **types**, and sometimes functions and operators behave differently based on the type.\n\n* **Functions** have both optional and required **arguments**.  They take input and produce output.\n\n* Data can be stored in multiple different **structures**. The choice of structure depends on the dimensionality (1D or 2D) and the homogeneity (do all elements need to be the same type?)\n\n* We use **indexing** to access (and edit) individual elements or sections of data structures.\n\n* We use **boolean masking** to find only the elements of a vector, matrix, or data frame that meet a particular qualification.\n\n* `python` is an **open-source language**.  We will `import` many different *libraries* to add to our basic functionality.\n\n### Practice Exercise\n\n:::{.callout-practice-exercise .icon}\nUse your new knowledge of objects, types, and common coding errors to [solve this puzzle](https://colab.research.google.com/drive/19q0g8JRwKIRjyLe0HG3Olwnp4VyeyX3P?usp=sharing)\n:::\n\n",
    "supporting": [
      "01-basics_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}